# 컨트롤러
컨트롤러는 수신한 **요청을** 처리하고 클라이언트에 **응답을** 반환합니다.
![controllers_1](https://docs.nestjs.com/assets/Controllers_1.png)
컨트롤러의 목적은 응용 프로그램에 대한 특정 요청을 받는 것입니다. 라우팅 메커니즘은 어떤 컨트롤러가 어떤 요청을 받는지 제어합니다. 종종 각 컨트롤러에는 하나 이상의 경로가 있으며 각기 다른 경로는 다른 작업을 수행 할 수 있습니다.

기본 컨트롤러를 만들기 위해 클래스와 데코레이터를 사용합니다. 데코레이터는 클래스를 필요한 메타 데이터와 연결하고 Nest가 라우팅 맵을 생성 할 수 있도록 합니다. (요청을 해당 컨트롤러에 연결하는 역할을 합니다.)

## 라우팅

다음 예제에서는 기본 컨트롤러를 정의하는 데 필요한 `@Controller()` 데코레이터를 사용합니다.선택적 경로 접두사를 지정합니다. `@Controller()` 데코레이터에서 경로 접두사를 사용하면 관련 경로 세트를 쉽게 그룹화하고 반복적인 코드를 최소화 할 수 있습니다. 예를 들어, /customer 경로 아래에서 Customer 엔티티와의 상호 작용을 관리하는 경로 세트를 그룹화하도록 선택할 수 있습니다. 이 경우 `@Controller()` 데코레이터에서 `customers`경로 접두사를 지정하여 파일의 각 경로에 대해 경로의 해당 부분을 반복 할 필요가 없습니다.
```typescript
cats.controllers.ts

import { Controller, Get } from '@nestjs/common';

@Controller('cats')
export class CatsController {
  @Get()
  findAll(): string {
    return 'This action returns all cats';
  }
}
```

?> 도움말 <br>
CLI를 사용하면 `nest g controller cats` 명령을 통해 간단하게 컨트롤러를 만들 수 있습니다.

`FindAll()` 메소드 앞의 `@Get()` HTTP 요청 메소드 데코레이터는 Nest에게 HTTP 요청에 대한 특정 엔드 포인트에 대한 핸들러를 작성하도록 지시합니다. 엔드 포인트는 HTTP 요청 메소드 (이 경우 GET) 및 라우트 경로에 해당합니다. 

 핸들러의 라우트 경로는 컨트롤러에 선언된 (선택적) 접두사와 요청 데코레이터에 지정된 경로를 연결하여 결정됩니다. 모든 경로 (고양이)에 대한 접두사를 선언하고 데코레이터에 경로 정보를 추가하지 않았으므로 Nest는 `GET /cats` 요청을 이 핸들러에 매핑합니다. 
 
 언급 한 바와 같이, 경로에는 선택적 컨트롤러 경로 접두사와 요청 메소드 데코레이터에 선언 된 모든 경로 문자열이 모두 포함됩니다. 예를 들어, 데코레이터 `@Get('profile')`과 결합된 `customer` 경로 접두사는 `GET /customers/profile`과 같은 요청에 대한 경로 매핑을 생성합니다.

위의 예에서 GET 요청이 엔드 포인트에 이루어지면 Nest는 요청을 사용자 정의 `findAll(`) 메소드로 라우팅합니다. 여기서, 선택한 이름은 임의적으로 작성 될 수 있습니다. 경로를 바인딩 할 메소드를 선언해야 하지만, Nest는 선택한 메소드 이름에 아무런 의미도 부여하지 않습니다.

이 메소드는 상태 코드 200 및 연관된 응답 (이 경우 문자열)을 반환합니다. 왜 이러한 일이 일어나는지 설명하기 위해 먼저 Nest가 응답을 조작하기 위해 두 가지 옵션을 사용한다는 개념을 소개합니다.

| 표준 (권장) 	| 내장 메소드를 사용하여 요청 핸들러가 JavaScript 오브젝트 또는 배열을 반환하면 자동으로 JSON으로 직렬화됩니다. 그러나 JavaScript 기본 유형 (예 : String, Number, Boolean)을 반환하면 Nest는 직렬화하려고 시도하지 않고 값만 보냅니다. 이는 응답 처리를 간단하게 만듭니다. 값을 반환하고 Nest가 나머지를 처리합니다. 또한 응답 상태 코드는 201을 사용하는 POST 요청 제외하고 기본적으로 항상 200입니다. `@HttpCode(...)` 데코레이터를 추가하여 이 동작을 핸들러 레벨에서 쉽게 변경할 수 있습니다. (상태 코드 참조) 	|
|-----------------	|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	|
| 라이브러리 별 정의 	| 메소드 핸들러 (예 : `findAll (@Res () response)`)에서 `@Res()` 데코레이터를 사용하여 라이브러리 별 (예 : `Express`) 응답 객체를 사용할 수 있습니다. 이 접근 방식을 사용하면 해당 객체에 의해 노출된 기본 응답 처리 방법을 사용할 수 있습니다. 예를 들어 `Express`를 사용하면 `response.status(200).send()`와 같은 코드를 사용하여 응답을 구성 할 수 있습니다. 	|

## Request 객체
핸들러는 종종 클라이언트의 Request 세부 사항에 접근합니다. Nest는 기본 플랫폼의 Request 객체에 대한 접근을 제공합니다. (기본적으로 `Express`입니다.) 
`@Req` 데코레이터를 핸들러에 추가하여 Nest에게 요청하면, Request 객체에 접근할 수 있습니다.
!> 경고 <br>
두 가지 방법을 동시에 사용할 수는 없습니다. Nest는 핸들러가 @Res()또는 @Next()를 선택했는지를 탐지합니다. 두 접근 방식을 동시에 사용하면이 단일 경로에 대해 표준 접근 방식이 자동으로 비활성화 됩니다.

```typescript
cats.controllers.ts

import { Controller, Get, Req } from '@nestjs/common';
import { Request } from 'express';

@Controller('cats')
export class CatsController {
  @Get()
  findAll(@Req() request: Request): string {
    return 'This action returns all cats';
  }
}
```

?> 도움말 <br>
위 `express`의 타입을 `request: Request`와 같이 매개 변수에서 활용 하려면 @`types/express` 패키지를 설치해야합니다.

## 리소스
## 와일드 카드 경로
## 상태 코드
## 헤더
## 넘겨주기
## 경로 매개변수
## 범위
## 비동기성
## 페이로드
## 에러 핸들링
